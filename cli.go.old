package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"math"
	"net/http"
	"os"
	"strings"

	"github.com/shirou/gopsutil/v4/cpu"
	"github.com/shirou/gopsutil/v4/disk"
	"github.com/shirou/gopsutil/v4/host"
	"github.com/shirou/gopsutil/v4/load"
	"github.com/shirou/gopsutil/v4/mem"
	"github.com/urfave/cli/v3"
)

var version = "dev"

// CheckPayload represents a single check to send to the API
type CheckPayload struct {
	Dashboard        string `json:"dashboard"`
	Site             string `json:"site"`
	Service          string `json:"service"`
	Name             string `json:"name"`
	AlertLevel       int    `json:"alert_level"`
	Message          string `json:"message,omitempty"`
	Value            string `json:"value,omitempty"`
	InactiveExpire   string `json:"inactive_expire,omitempty"`
	InactiveEscalate string `json:"inactive_escalate,omitempty"`
	Highlighted      string `json:"highlighted,omitempty"`
}

// APIResponse represents the response from the API
type APIResponse struct {
	Status string   `json:"status"`
	Errors []string `json:"errors,omitempty"`
}

func parseAlertLevel(level string) (int, error) {
	switch strings.ToLower(level) {
	case "ok":
		return 0, nil
	case "warn":
		return 1, nil
	case "alert":
		return 2, nil
	default:
		return -1, fmt.Errorf("invalid alert level: %s (must be ok, warn, or alert)", level)
	}
}

func main() {
	cmd := &cli.Command{
		Name:    "alertbingo",
		Usage:   "CLI tool for sending checks to Alert Bingo",
		Version: version,
		Commands: []*cli.Command{
			{
				Name:  "hoststats",
				Usage: "Send host statistics checks (memory, uptime, CPU) to Alert Bingo",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:     "dashboard",
						Aliases:  []string{"d"},
						Usage:    "Dashboard name",
						Sources:  cli.EnvVars("ALERTBINGO_DASHBOARD"),
						Required: true,
					},
					&cli.StringFlag{
						Name:     "site",
						Aliases:  []string{"s"},
						Usage:    "Site identifier (e.g., myapp-prod)",
						Sources:  cli.EnvVars("ALERTBINGO_SITE"),
						Required: true,
					},
					&cli.StringFlag{
						Name:     "service",
						Usage:    "Service name (e.g., host)",
						Sources:  cli.EnvVars("ALERTBINGO_SERVICE"),
						Required: true,
					},
					&cli.StringFlag{
						Name:    "message",
						Aliases: []string{"m"},
						Usage:   "Optional long-form status message",
						Sources: cli.EnvVars("ALERTBINGO_MESSAGE"),
					},
					&cli.StringFlag{
						Name:    "inactive-expire",
						Usage:   "Optional duration string for inactive expiry (e.g., 48h or 30m)",
						Sources: cli.EnvVars("ALERTBINGO_INACTIVE_EXPIRE"),
					},
					&cli.StringFlag{
						Name:    "inactive-escalate",
						Usage:   "Optional duration string for inactive escalation (e.g., 1h or 30m)",
						Sources: cli.EnvVars("ALERTBINGO_INACTIVE_ESCALATE"),
					},
					&cli.StringFlag{
						Name:    "highlighted",
						Usage:   "Optional highlighted status",
						Sources: cli.EnvVars("ALERTBINGO_HIGHLIGHTED"),
					},
					&cli.StringFlag{
						Name:     "token",
						Aliases:  []string{"t"},
						Usage:    "API Bearer token",
						Sources:  cli.EnvVars("ALERTBINGO_TOKEN"),
						Required: true,
					},
					&cli.StringFlag{
						Name:    "api-url",
						Usage:   "API URL",
						Sources: cli.EnvVars("ALERTBINGO_API_URL"),
						Value:   "https://app.alert.bingo/api/v1/checks",
					},
				},
				Action: func(ctx context.Context, cmd *cli.Command) error {
					// Collect host statistics
					checks, err := collectHostStats(ctx, cmd)
					if err != nil {
						return fmt.Errorf("failed to collect host stats: %w", err)
					}

					jsonData, err := json.Marshal(checks)
					if err != nil {
						return fmt.Errorf("failed to marshal payload: %w", err)
					}

					apiURL := cmd.String("api-url")
					token := cmd.String("token")

					req, err := http.NewRequestWithContext(ctx, "POST", apiURL, bytes.NewBuffer(jsonData))
					if err != nil {
						return fmt.Errorf("failed to create request: %w", err)
					}

					req.Header.Set("Accept", "application/json")
					req.Header.Set("Content-Type", "application/json")
					req.Header.Set("Authorization", "Bearer "+token)

					client := &http.Client{}
					resp, err := client.Do(req)
					if err != nil {
						return fmt.Errorf("failed to send request: %w", err)
					}
					defer resp.Body.Close()

					body, err := io.ReadAll(resp.Body)
					if err != nil {
						return fmt.Errorf("failed to read response body: %w", err)
					}

					if resp.StatusCode != http.StatusOK {
						return fmt.Errorf("request failed with status %d: %s", resp.StatusCode, formatResponseSummary(body))
					}

					fmt.Println("Host stats checks sent successfully")

					// Parse response and report any non-OK statuses and errors
					if summary := formatResponseSummary(body); summary != "" {
						fmt.Println(summary)
					}

					return nil
				},
			},
			{
				Name:  "check",
				Usage: "Send a check to Alert Bingo",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:     "dashboard",
						Aliases:  []string{"d"},
						Usage:    "Dashboard name",
						Sources:  cli.EnvVars("ALERTBINGO_DASHBOARD"),
						Required: true,
					},
					&cli.StringFlag{
						Name:     "site",
						Aliases:  []string{"s"},
						Usage:    "Site identifier (e.g., myapp-prod)",
						Sources:  cli.EnvVars("ALERTBINGO_SITE"),
						Required: true,
					},
					&cli.StringFlag{
						Name:     "service",
						Usage:    "Service name (e.g., postgres)",
						Sources:  cli.EnvVars("ALERTBINGO_SERVICE"),
						Required: true,
					},
					&cli.StringFlag{
						Name:     "name",
						Aliases:  []string{"n"},
						Usage:    "Check name (e.g., postgres-rds-space-free)",
						Sources:  cli.EnvVars("ALERTBINGO_NAME"),
						Required: true,
					},
					&cli.StringFlag{
						Name:    "alert-level",
						Aliases: []string{"l"},
						Usage:   "Alert level: ok, warn, or alert",
						Sources: cli.EnvVars("ALERTBINGO_ALERT_LEVEL"),
						Value:   "ok",
					},
					&cli.StringFlag{
						Name:    "message",
						Aliases: []string{"m"},
						Usage:   "Optional long-form status message",
						Sources: cli.EnvVars("ALERTBINGO_MESSAGE"),
					},
					&cli.StringFlag{
						Name:    "value",
						Aliases: []string{"v"},
						Usage:   "Short-form status value",
						Sources: cli.EnvVars("ALERTBINGO_VALUE"),
					},
					&cli.StringFlag{
						Name:    "inactive-expire",
						Usage:   "Optional duration string for inactive expiry (e.g., 48h or 30m)",
						Sources: cli.EnvVars("ALERTBINGO_INACTIVE_EXPIRE"),
					},
					&cli.StringFlag{
						Name:    "inactive-escalate",
						Usage:   "Optional duration string for inactive escalation (e.g., 1h or 30m)",
						Sources: cli.EnvVars("ALERTBINGO_INACTIVE_ESCALATE"),
					},
					&cli.StringFlag{
						Name:    "highlighted",
						Usage:   "Optional highlighted status",
						Sources: cli.EnvVars("ALERTBINGO_HIGHLIGHTED"),
					},
					&cli.StringFlag{
						Name:     "token",
						Aliases:  []string{"t"},
						Usage:    "API Bearer token",
						Sources:  cli.EnvVars("ALERTBINGO_TOKEN"),
						Required: true,
					},
					&cli.StringFlag{
						Name:    "api-url",
						Usage:   "API URL",
						Sources: cli.EnvVars("ALERTBINGO_API_URL"),
						Value:   "https://app.alert.bingo/api/v1/checks",
					},
				},
				Action: func(ctx context.Context, cmd *cli.Command) error {
					alertLevelStr := cmd.String("alert-level")
					alertLevel, err := parseAlertLevel(alertLevelStr)
					if err != nil {
						return err
					}

					payload := CheckPayload{
						Dashboard:        cmd.String("dashboard"),
						Site:             cmd.String("site"),
						Service:          cmd.String("service"),
						Name:             cmd.String("name"),
						AlertLevel:       alertLevel,
						Message:          cmd.String("message"),
						Value:            cmd.String("value"),
						InactiveExpire:   cmd.String("inactive-expire"),
						InactiveEscalate: cmd.String("inactive-escalate"),
						Highlighted:      cmd.String("highlighted"),
					}

					payloadSlice := []CheckPayload{payload}
					jsonData, err := json.Marshal(payloadSlice)
					if err != nil {
						return fmt.Errorf("failed to marshal payload: %w", err)
					}

					apiURL := cmd.String("api-url")
					token := cmd.String("token")

					req, err := http.NewRequestWithContext(ctx, "POST", apiURL, bytes.NewBuffer(jsonData))
					if err != nil {
						return fmt.Errorf("failed to create request: %w", err)
					}

					req.Header.Set("Accept", "application/json")
					req.Header.Set("Content-Type", "application/json")
					req.Header.Set("Authorization", "Bearer "+token)

					client := &http.Client{}
					resp, err := client.Do(req)
					if err != nil {
						return fmt.Errorf("failed to send request: %w", err)
					}
					defer resp.Body.Close()

					body, err := io.ReadAll(resp.Body)
					if err != nil {
						return fmt.Errorf("failed to read response body: %w", err)
					}

					if resp.StatusCode != http.StatusOK {
						return fmt.Errorf("request failed with status %d: %s", resp.StatusCode, formatResponseSummary(body))
					}

					fmt.Println("Check sent successfully")

					// Parse response and report any non-OK statuses and errors
					if summary := formatResponseSummary(body); summary != "" {
						fmt.Println(summary)
					}

					return nil
				},
			},
		},
	}

	if err := cmd.Run(context.Background(), os.Args); err != nil {
		log.Fatal(err)
	}
}

// collectHostStats gathers memory, uptime, and CPU statistics and returns check payloads
func collectHostStats(ctx context.Context, cmd *cli.Command) ([]CheckPayload, error) {
	dashboard := cmd.String("dashboard")
	site := cmd.String("site")
	service := cmd.String("service")
	message := cmd.String("message")
	inactiveExpire := cmd.String("inactive-expire")
	inactiveEscalate := cmd.String("inactive-escalate")
	highlighted := cmd.String("highlighted")

	var checks []CheckPayload

	// Memory check
	vmem, err := mem.VirtualMemoryWithContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get virtual memory: %w", err)
	}
	memPercent := int(math.Ceil(vmem.UsedPercent))
	memAlertLevel := 0 // ok
	memMessage := message
	if memPercent >= 95 {
		memAlertLevel = 1 // warn
		memMessage = appendAlertReason(message, "Memory % over 95")
	}
	checks = append(checks, CheckPayload{
		Dashboard:        dashboard,
		Site:             site,
		Service:          service,
		Name:             "Memory",
		AlertLevel:       memAlertLevel,
		Value:            fmt.Sprintf("%d%%", memPercent),
		Message:          memMessage,
		InactiveExpire:   inactiveExpire,
		InactiveEscalate: inactiveEscalate,
		Highlighted:      highlighted,
	})

	// Uptime check
	hostInfo, err := host.InfoWithContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get host info: %w", err)
	}
	uptimeDays := int(hostInfo.Uptime / 86400) // seconds to days
	uptimeAlertLevel := 0                      // ok
	uptimeMessage := message
	if uptimeDays < 1 {
		uptimeAlertLevel = 1 // warn
		uptimeMessage = appendAlertReason(message, "Uptime less than 1 day")
	}
	checks = append(checks, CheckPayload{
		Dashboard:        dashboard,
		Site:             site,
		Service:          service,
		Name:             "Uptime",
		AlertLevel:       uptimeAlertLevel,
		Value:            fmt.Sprintf("%dd", uptimeDays),
		Message:          uptimeMessage,
		InactiveExpire:   inactiveExpire,
		InactiveEscalate: inactiveEscalate,
		Highlighted:      highlighted,
	})

	// CPU check (load average / CPU count)
	loadAvg, err := load.AvgWithContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get load average: %w", err)
	}
	cpuCount, err := cpu.CountsWithContext(ctx, true) // logical cores
	if err != nil {
		return nil, fmt.Errorf("failed to get CPU count: %w", err)
	}
	cpuPercent := int(math.Ceil((loadAvg.Load1 / float64(cpuCount)) * 100))
	if cpuPercent > 100 {
		cpuPercent = 100 // cap at 100%
	}
	cpuAlertLevel := 0 // ok
	cpuMessage := message
	if cpuPercent == 100 {
		cpuAlertLevel = 1 // warn
		cpuMessage = appendAlertReason(message, "CPU % at 100")
	}
	checks = append(checks, CheckPayload{
		Dashboard:        dashboard,
		Site:             site,
		Service:          service,
		Name:             "CPU",
		AlertLevel:       cpuAlertLevel,
		Value:            fmt.Sprintf("%d%%", cpuPercent),
		Message:          cpuMessage,
		InactiveExpire:   inactiveExpire,
		InactiveEscalate: inactiveEscalate,
		Highlighted:      highlighted,
	})

	// Disk Used check (for "/" partition)
	diskUsage, err := disk.UsageWithContext(ctx, "/")
	if err != nil {
		return nil, fmt.Errorf("failed to get disk usage: %w", err)
	}
	diskUsedPercent := int(math.Ceil(diskUsage.UsedPercent))
	diskUsedAlertLevel := 0 // ok
	diskUsedMessage := message
	if diskUsedPercent > 99 {
		diskUsedAlertLevel = 2 // alert
		diskUsedMessage = appendAlertReason(message, "Disk Used % over 99")
	} else if diskUsedPercent > 95 {
		diskUsedAlertLevel = 1 // warn
		diskUsedMessage = appendAlertReason(message, "Disk Used % over 95")
	}
	checks = append(checks, CheckPayload{
		Dashboard:        dashboard,
		Site:             site,
		Service:          service,
		Name:             "Disk Used",
		AlertLevel:       diskUsedAlertLevel,
		Value:            fmt.Sprintf("%d%%", diskUsedPercent),
		Message:          diskUsedMessage,
		InactiveExpire:   inactiveExpire,
		InactiveEscalate: inactiveEscalate,
		Highlighted:      highlighted,
	})

	// Disk Inodes check (for "/" partition)
	diskInodesPercent := int(math.Ceil(diskUsage.InodesUsedPercent))
	diskInodesAlertLevel := 0 // ok
	diskInodesMessage := message
	if diskInodesPercent > 99 {
		diskInodesAlertLevel = 2 // alert
		diskInodesMessage = appendAlertReason(message, "Disk Inodes % over 99")
	} else if diskInodesPercent > 95 {
		diskInodesAlertLevel = 1 // warn
		diskInodesMessage = appendAlertReason(message, "Disk Inodes % over 95")
	}
	checks = append(checks, CheckPayload{
		Dashboard:        dashboard,
		Site:             site,
		Service:          service,
		Name:             "Disk Inodes",
		AlertLevel:       diskInodesAlertLevel,
		Value:            fmt.Sprintf("%d%%", diskInodesPercent),
		Message:          diskInodesMessage,
		InactiveExpire:   inactiveExpire,
		InactiveEscalate: inactiveEscalate,
		Highlighted:      highlighted,
	})

	return checks, nil
}

// appendAlertReason appends an alert reason to an existing message
func appendAlertReason(message, reason string) string {
	if message == "" {
		return reason
	}
	return message + " - " + reason
}

// formatResponseSummary returns a formatted summary of non-OK statuses and errors from API response array
func formatResponseSummary(body []byte) string {
	var responses []APIResponse
	if err := json.Unmarshal(body, &responses); err != nil {
		// If JSON parsing fails, return the raw body
		return string(body)
	}

	// Collect unique non-OK statuses
	statusSet := make(map[string]struct{})
	for _, resp := range responses {
		if strings.ToUpper(resp.Status) != "OK" {
			statusSet[resp.Status] = struct{}{}
		}
	}

	// Collect unique errors
	errorSet := make(map[string]struct{})
	for _, resp := range responses {
		for _, e := range resp.Errors {
			errorSet[e] = struct{}{}
		}
	}

	var parts []string

	// Format unique non-OK statuses
	if len(statusSet) > 0 {
		var statuses []string
		for s := range statusSet {
			statuses = append(statuses, s)
		}
		parts = append(parts, fmt.Sprintf("Statuses: %s", strings.Join(statuses, ", ")))
	}

	// Format unique errors
	if len(errorSet) > 0 {
		var errors []string
		for e := range errorSet {
			errors = append(errors, e)
		}
		parts = append(parts, fmt.Sprintf("Errors: %s", strings.Join(errors, ", ")))
	}

	return strings.Join(parts, "; ")
}
